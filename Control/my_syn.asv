function [K, CL, normz, xfeas] = my_syn(varargin)
%MY_SYN Discrete-Time Multiobjective Optimal Control Using Extended LMI 
% Approach
%   Generates optimal or sub-optimal controller in the l1, H2, or Hinf 
%   sense using the simplified LMI approach from [1], [2]. Produces 
%   discrete-time controllers for discrete-time plants.
%
%   Inputs:
%       P: stabilizable and detectable real rational proper LTI plant.
%       NMEAS: number of measured variables or controller y inputs. 
%       (optional, default: 1 less than total plant outputs.)
%       NCON: number of controlled variables or controller u outputs. 
%       (optional, default: 1 less than total plant inputs).
%       W1: vector indicating which generalized plant disturbance input
%       channels are under l1 constraint. (optional, default: [])
%       W2: vector indicating which generalized plant disturbance input
%       channels are under H2 constraint. (optional, default: [])
%       WINF: vector indicating which generalized plant disturbance input
%       channels are under HInf constraint. (optional, default: [])
%       Z1: vector indicating which generalized plant performance output
%       channels are under l1 constraint. (optional, default: [])
%       Z2: vector indicating which generalized plant performance output
%       channels are under H2 constraint. (optional, default: [])
%       ZINF: vector indicating which generalized plant performance output
%       channels are under HInf constraint. (optional, default: [])
%       L1MAX: if this name-value parameter is specified, a sub-optimal 
%       l1 controller is designed to the value given. If unspecified or 
%       negative, an optimal l1 controller is designed to minimize the l1 
%       norm of the performance bound L1MAX. If L1MAX == Inf, constraint is
%       ignored.  
%       H2MAX: if this name-value parameter is specified, a sub-optimal 
%       H2 controller is designed to the value given. If unspecified or 
%       negative, an optimal H2 controller is designed to minimize the H2 
%       norm of the performance bound H2MAX. If H2MAX == Inf, constraint is
%       ignored.
%       HINFMAX: if this name-value parameter is specified, a sub-optimal 
%       HInf controller is designed to the value given. If unspecified or 
%       negative, an optimal HInf controller is designed to minimize the 
%       HInf norm of the performance bound HINFMAX. If HINFMAX == Inf, 
%       constraint is ignored.
%       DISPLAY: 'on' | 'off' (default), name-value parameter to specify if
%       the LMI solver should output progress information.
%       
%   Outputs:
%       K: H-infinity controller state-space model.
%       CL: closed loop system, equivalent to lft(P, K).
%       normz: H-infinity bound from w to z, minimized if GAM input was
%       unspecified.
%       xfeas: Sedumi optimizer structure output.
%   
%   See also: H2HINFSYN, MY_H2HINFSYN
%       [1] A. Oberoi and J. C. Cockburn, “A simplified LMI approach to l1 
%           Controller Design,” Proc. 2005 Am. Control Conf., no. July, pp. 
%           1788–1792, 2005.
%       [2] M. C. De Oliveira, J. C. Geromel, and J. Bernussou, “Extended 
%           H2 and H? norm characterizations and controller 
%           parametrizations for discrete-time systems,” Int. J. Control, 
%           vol. 75, no. 9, pp. 666–679, 2002.
%
%   $Author: BH $    $Date: 2017-12-20 $    $Revision: 1 $

%% Deal with variable function inputs.
    p = inputParser;
    addRequired(p, 'P', @(x) isa(x, 'ss') || isa(x, 'tf'));
    parse(p, varargin{1});
    G = p.Results.P;
    if ~isa(G, 'ss') % Convert other LTI models to state space form.
        G = ss(G);
    end
    addOptional(p, 'NMEAS', max(size(G.C, 1) - 2, 1), @(x) isnumeric(x) && isscalar(x));
    addOptional(p, 'NCON', max(size(G.B, 2) - 2, 1), @(x) isnumeric(x) && isscalar(x));
    addOptional(p, 'W1', 1, @(x) isnumeric(x));
    addOptional(p, 'W2', 2, @(x) isnumeric(x));
    addOptional(p, 'WINF', 3, @(x) isnumeric(x));
    addOptional(p, 'Z1', 1, @(x) isnumeric(x));
    addOptional(p, 'Z2', 2, @(x) isnumeric(x));
    addOptional(p, 'ZINF', 3, @(x) isnumeric(x));
    addParameter(p, 'L1MAX', -1, @(x) isnumeric(x) && isscalar(x));
    addParameter(p, 'H2MAX', -1, @(x) isnumeric(x) && isscalar(x));
    addParameter(p, 'HINFMAX', -1, @(x) isnumeric(x) && isscalar(x));
    addParameter(p, 'DISPLAY', 'off', @(x) ismember(x, {'on', 'off'}));
    addParameter(p, 'EXTENDED', true, @(x) isscalar(x) && islogical(x));
    parse(p, varargin{:});
    n = length(G.A);
    ny = p.Results.NMEAS; 
    nu = p.Results.NCON;
    psi_in = p.Results.L1MAX;
    traceOutput = strcmp(p.Results.DISPLAY, 'on');
    isExtended = p.Results.EXTENDED;

    if G.Ts == 0
        error('my_h2hinfsyn2:ctplant', 'Continuous-time plants are not supported.');
    end
    
    [A, B, C, D] = partitionplant(G, ny, nu, p.Results.W1, p.Results.W2, p.Results.WINF, p.Results.Z1, p.Results.Z2, p.Results.ZINF);
    
    %% Check Assumptions.
    P_2 = ss(A, B{4}, C{4}, D{4,4}, G.Ts); % State-space model for testing stability.
    [~, P_us] = stabsep(P_2);
    if rank(ctrb(P_us.A, P_us.B)) < size(P_us.A, 1) % Unstabilizable.
        error('my_hinfsyn:unstab', 'Stabilizability assumption is violated.');
    end
    if rank(obsv(P_us.A, P_us.C)) < size(P_us.A, 2) % Undetectable.
        error('my_hinfsyn:undet', 'Detectability assumption is violated.');
    end
    if all(D{4,4}==0)
        isFeedforward = false;
    else
        isFeedforward = true;
    end
    
    if psi_in == -1
        psi = sdpvar(1); % Optimization problem.
    else
        psi = psi_in.^2; % Sub-optimal (feasibility) problem.
    end
    
    function [linObjective, xfeas] = ymOptimize(linValue, isVerbose)

        % Scalars:
        alpha = linValue;
        mu = sdpvar(1);
        nu_1 = sdpvar(1);
        % Matrices:
        P = sdpvar(n);
        H = sdpvar(n);
        if isExtended
            X = sdpvar(n, n, 'full');
            S = sdpvar(n, n, 'full');
            J = sdpvar(n, n, 'full');
            Y = sdpvar(n, n, 'full');
        else
            X = P;
            S = eye(n);
            J = eye(n);
            Y = H;
        end
        L = sdpvar(nu, n, 'full');
        F = sdpvar(n, ny, 'full');
        Q = sdpvar(n, n, 'full');
        R = sdpvar(nu, ny, 'full');

        ymLmi = {};
        ymConstraint = [];%[norm(X)<=1e3, norm(Y)<=1e3]; % Added to fix numerical problems.
        ymLmi{1} = blkvar;
        ymLmi{1}(1,1) = alpha*(X + X' - P); % alpha*(X + X' - P)
        ymLmi{1}(1,2) = alpha*(eye(n) + S' - J); % alpha*(I_n + S' - J)
        ymLmi{1}(1,3) = zeros(n, nw);
        ymLmi{1}(1,4) = X'*C{1}' + L'*D{1,2}'; % X'*C_z' + L'*D_zu'
        ymLmi{1}(2,2) = alpha*(Y + Y' - H); % alpha*(Y + Y' - H)
        ymLmi{1}(2,3) = zeros(n, nw);
        ymLmi{1}(2,4) = C{1}' + C{2}'*R'*D{1,2}'; % C_z' + C_y'*R'*D_zu'
        ymLmi{1}(3,3) = (mu - 1)*eye(nw); % (mu - 1)*I_nw
        ymLmi{1}(3,4) = D{1,1}' + D{2,1}'*R'*D{1,2}'; % D_zw' + D_yw'*R'*D_zu'
        ymLmi{1}(4,4) = nu_1*eye(nz); % nu*I_nz
        ymLmi{1} = sdpvar(ymLmi{1});
        ymConstraint = [ymConstraint, ymLmi{1}>=0];
        ymLmi{2} = blkvar;
        ymLmi{2}(1,1) = P; % P
        ymLmi{2}(1,2) = J; % J
        ymLmi{2}(1,3) = A*X + B{2}*L; % A*X + B_u*L
        ymLmi{2}(1,4) = A + B{2}*R*C{2}; % A + B_u*R*C_y
        ymLmi{2}(1,5) = B{1} + B{2}*R*D{2,1}; % B_w + B_u*R*D_yw
        ymLmi{2}(2,2) = H; % H
        ymLmi{2}(2,3) = Q; % Q
        ymLmi{2}(2,4) = Y*A + F*C{2}; % Y*A + F*C_y
        ymLmi{2}(2,5) = Y*B{1} + F*D{2,1}; % Y*B_w + F*D_yw
        ymLmi{2}(3,3) = (1 - alpha)*(X + X' - P); % (1 - alpha)*(X + X' - P)
        ymLmi{2}(3,4) = (1 - alpha)*(eye(n) + S' - J); % (1 - alpha)*(I_n + S' - J)
        ymLmi{2}(3,5) = zeros(n, nw);
        ymLmi{2}(4,4) = (1 - alpha)*(Y + Y' - H); % (1 - alpha)*(Y + Y' - H)
        ymLmi{2}(4,5) = zeros(n, nw);
        ymLmi{2}(5,5) = eye(nw); % I_nw
        ymLmi{2} = sdpvar(ymLmi{2});
        ymConstraint = [ymConstraint, ymLmi{2}>=0];
        ymLmi{3} = blkvar;
        ymLmi{3}(1,1) = psi;
        ymLmi{3}(1,2) = mu;
        ymLmi{3}(1,3) = nu_1;
        ymLmi{3}(2,2) = 1;
        ymLmi{3}(3,3) = 1;
        ymLmi{3} = sdpvar(ymLmi{3});
        ymConstraint = [ymConstraint, ymLmi{3}>=0];   

        %% Solve LMI Minimization Problem.
        if psi_in==-1
            ymObjective = psi;
        else
            ymObjective = [];
        end
        ymOptions = sdpsettings('verbose', isVerbose, 'solver', 'sedumi');
        xfeas = optimize(ymConstraint, ymObjective, ymOptions);
        linObjective = value(psi);
    end
end

function [A, B, C, D] = partitionplant(P, ny, nu, w_1, w_2, w_inf, z_1, z_2, z_inf)
%PARTITIONPLANT Modify plant for multiobjective synthesis.
%   Permutes the inputs and outputs of the plant P so that each
%   input/output group is separate for specifying performance criteria.
%   
%   Inputs:
%       P: state-space generalized plant.
%       ny: numeric scalar number of output channels (controller 
%       measurement channels). Outputs are the last ny output channels.
%       nu: numeric scalar number of input channels (controller controlled 
%       channels). Inputs are the last nu input channels.
%       w_1: numeric vector of disturbance input channel indices under l1 
%       norm constraint.
%       w_2: numeric vector of disturbance input channel indices under H2 
%       norm constraint.
%       w_inf: numeric vector of disturbance input channel indices under 
%       HInf norm constraint.
%       z_1: numeric vector of performance output channel indices under l1 
%       norm constraint.
%       z_2: numeric vector of performance output channel indices under H2 
%       norm constraint.
%       z_inf: numeric vector of performance output channel indices under 
%       HInf norm constraint.
%       
%   Outputs:
%       A: state-space A matrix (equal to P.A).
%       B: 1x4 cell array of partitioned state-space B matrices.
%       C: 4x1 cell array of partitioned state-space C matrices.
%       D: 4x4 cell array of partitioned state-space D matrices.
%
%   $Author: BH $    $Date: 2017-12-20 $    $Revision: 1 $

    %% Plant partitioning:
    %       In:    x    w_inf   w_2    w_1     u
    %              |      |      |      |      |
    % Out:         V      V      V      V      V
    %          .----------------------------------.
    % dx/dt <- |   A  |  B_1 |  B_2 |  B_3 |  B_4 | n
    %          |------|------|------|------|------|
    % z_inf <- |  C_1 | D_11 | D_12 | D_13 | D_14 | nz_inf
    %          |------|------|------|------|------|
    %   z_2 <- |  C_2 | D_21 | D_22 | D_23 | D_24 | nz_2
    %          |------|------|------|------|------|
    %   z_1 <- |  C_3 | D_31 | D_32 | D_33 | D_34 | nz_1
    %          |------|------|------|------|------|
    %     y <- |  C_4 | D_41 | D_42 | D_43 | D_44 | ny
    %          '----------------------------------'
    %      Size:   n   nw_inf  nw_2   nw_1    nu
    
    %% Permute rows and columns.
    ABCD = [P.A P.B; P.C P.D]; % Doyle representation.
    nx = length(P.A);
    ABCD = ABCD(:,nx+[w_1 w_2 w_inf]);
    ABCD = ABCD(nx+[z_1 z_2 z_inf],:);
    
    %% Number of channels for each input/output group.
    nw_1 = numel(w_1); nw_2 = numel(w_2); nw_inf = numel(w_inf);
    nz_1 = numel(z_1); nz_2 = numel(z_2); nz_inf = numel(z_inf);
    
    %% Split into cell array.
    B = mat2cell(ABCD(1:nx,nx+1:end), nx, [nw_1 nw_2 nw_inf nu]);
    C = mat2cell(ABCD(nx+1:end,1:nx), [nz_1 nz_2 nz_inf ny], nx);
    D = mat2cell(ABCD(nx+1:end,nx+1:end), [nz_1 nz_2 nz_inf ny], [nw_1 nw_2 nw_inf nu]);
end